# ethereum-optimism/design-docs Daily Update (Oct 14, 2025)
## OVERVIEW 
Today's focus was on architectural documentation for the Kona Rollup Node and refining failure mode analysis. Several issues related to `op-dispute-mon` and Flashblocks were actively discussed and resolved.

## KEY TECHNICAL DEVELOPMENTS

### Rollup Node Architecture Documentation
A new architecture document for the `kona-node` (Kona Rollup Node) was added, detailing its design and comparing it to the `op-node`, complete with diagrams for better visualization ([#264](https://github.com/ethereum-optimism/design-docs/pull/264)).

### Security and Failure Mode Analysis
Updates were made to the generic failure mode documentation for "Chain split driven by L1 chain split" and an action item for public runbook publication was modified ([#347](https://github.com/ethereum-optimism/design-docs/pull/347), [#348](https://github.com/ethereum-optimism/design-docs/pull/348)).

## NEWLY OPENED PULL REQUESTS
- [#345](https://github.com/ethereum-optimism/design-docs/pull/345) docs: removed dead links

## CLOSED ISSUES

### Flashblocks Proxy Resolution
An issue concerning the loss of Flashblocks when forwarding from rollup-boost to RPC nodes was identified and resolved, with new upgrades to the Flashblocks-websocket-proxy fixing connectivity and subscriber pong timeout problems ([#17856](https://github.com/ethereum-optimism/design-docs/issues/17856)).

### Flashblocks RPC Coordination
Coordination with Flashblocks RPC providers regarding the new Flashblocks RPC node was completed, with most providers confirming their integration and Blockscout planning to complete it later in the week ([#17857](https://github.com/ethereum-optimism/design-docs/issues/17857)).

## NEW ISSUES
No new issues were opened today.

## ACTIVE ISSUES

### op-dispute-mon: Fix handling of out of sync nodes ([#17814](https://github.com/ethereum-optimism/design-docs/issues/17814))
Discussion revolved around how `op-dispute-mon` should handle out-of-sync rollup RPCs. The latest comments indicate a preference for using the `syncStatus` to determine if a node is sufficiently in sync, rather than solely relying on the highest L2 block, which could be from an incorrect fork. A proposed solution involves using the highest unsafe block across all nodes as the expected current L2 head and ignoring results from nodes that are behind. The issue was briefly closed by mistake and then reopened for further resolution.